
paper.install(window);

const WINDOW_WIDTH  = 960;
const WINDOW_HEIGHT = 720;
const PERMITIVITY   = 9 * Math.pow(10, 9);

const ELECTRON_CHARGE = -1.602 * Math.pow(10, -19);
const PROTON_CHARGE   = -ELECTRON_CHARGE;
const PROTON_MASS     = 1.6727 * Math.pow(10, -27);
const Neutron_MASS    = 1.6750 * Math.pow(10, -27);
const ELECTRON_MASS   =  9.110 * Math.pow(10, -31);

class Particle {
    // x, y, radius
    constructor(args) {
        _.assign(this, _.defaults(args, {
            x: WINDOW_WIDTH / 2,
            y: WINDOW_HEIGHT / 2,
            radius: 8,
            color: 'red',
            velocityX: 0,            // m/s
            velocityY: 0,            // m/s
            accelX: 0,               // m/s
            accelY: 0,               // m/s
            charge: ELECTRON_CHARGE, // C
            mass: ELECTRON_MASS      // kg
        }));
    }

    draw() {
        this.circle = new Path.Circle(new Point(this.x, this.y), this.radius);
        this.circle.fillColor = this.color;
    }

    on(event, func) {
        this.circle['on' + _.capitalize(event)] = func;
    }

    reactToElectricFieldDueTo(otherParticle) {
        const distanceX = (this.circle.position.x - otherParticle.circle.position.x); // 1 pxl = 1cm
        const distanceY = (this.circle.position.y - otherParticle.circle.position.y); // 1 pyl = 1cm
        var forceX = 0,
            forceY = 0;

        if (distanceX != 0) {
            forceX = PERMITIVITY * ((this.charge * otherParticle.charge)
                                    / Math.pow(distanceX, 2));
        }
        if (distanceY != 0) {
            forceY = PERMITIVITY * ((this.charge * otherParticle.charge)
                                    / Math.pow(distanceY, 2));
        }
        this.accelX = forceX / this.mass;
        this.accelY = forceY / this.mass;
    }

    advanceInTime(milliseconds) {
        const seconds = milliseconds / 1000;
        this.velocityX += this.accelX * seconds;
        this.velocityY += this.accelY * seconds;
        this.circle.translate(new Point(this.velocityX, this.velocityY));
    }

}

window.onload = function() {
    paper.setup('canvas');

    // var circlePath = new Path.Circle(new Point(50, 50), 25);
    // circlePath.fillColor = "red";

    // setTimeout(function() { circlePath.fillColor = "blue"; }, 2000);

    // circlePath.onClick = function(circle) {
    //     console.log("you clicked circle " + circle);
    // }

    var p0 = new Particle({
        x: 100,
        y: 300
    });
    p0.draw();

    var p1 = new Particle({
        x: 200,
        y: 300
    });
    p1.draw();

    const frameLengthMillis = 1000/30;

    setInterval(function() {
        p1.reactToElectricFieldDueTo(p0);
        p1.advanceInTime(frameLengthMillis);
        p0.reactToElectricFieldDueTo(p1);
        p0.advanceInTime(frameLengthMillis);
    }, frameLengthMillis);
}
